<net.rptools.maptool.model.MacroButtonProperties>
  <macroUUID>f5781d38-97ab-4d0e-856c-1658bea9b35a</macroUUID>
  <saveLocation>Token</saveLocation>
  <index>34</index>
  <colorKey>default</colorKey>
  <hotKey>None</hotKey>
  <command>[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1): skillName = arg(1); skillName = "_all"]
&lt;!-- Constants --&gt;
&lt;!-- If we have to revisit skill searching, we may be able to convert the search from --&gt;
&lt;!-- change entityId to valueId to match up with the pattern in saving throw --&gt;
&lt;!-- entityId to typeId == 23 --&gt;
[h: SKILL_ENTITY_TYPE_ID = "1958004211"]

&lt;!-- oddly enough, toon has no base information for skills, only bonuses. So we have --&gt;
&lt;!-- to build it from scratch --&gt;
&lt;!-- oh fuck, the only thing in the toon to point to individual skills are jackass valueIds --&gt;
&lt;!-- So Ima need to map those, also --&gt;
[h: preSkills = json.append ("",
		json.set ("", "name", "Acrobatics", "ability", "dex", "entityId", "3"),
		json.set ("", "name", "Animal Handling", "ability", "wis", "entityId", "11"),
		json.set ("", "name", "Arcana", "ability", "int", "entityId", "6"),
		json.set ("", "name", "Athletics", "ability", "str", "entityId", "2"),
		json.set ("", "name", "Deception", "ability", "cha", "entityId", "16"),
		json.set ("", "name", "History", "ability", "int", "entityId", "7"),
		json.set ("", "name", "Insight", "ability", "wis", "entityId", "12"),
		json.set ("", "name", "Intimidation", "ability", "cha", "entityId", "17"),
		json.set ("", "name", "Investigation", "ability", "int", "entityId", "8"),
		json.set ("", "name", "Medicine", "ability", "wis", "entityId", "13"),
		json.set ("", "name", "Nature", "ability", "int", "entityId", "9"),
		json.set ("", "name", "Perception", "ability", "wis", "entityId", "14"),
		json.set ("", "name", "Performance", "ability", "cha", "entityId", "18"),
		json.set ("", "name", "Persuasion", "ability", "cha", "entityId", "19"),
		json.set ("", "name", "Religion", "ability", "int", "entityId", "10"),
		json.set ("", "name", "Sleight of Hand", "ability", "dex", "entityId", "4"),
		json.set ("", "name", "Stealth", "ability", "dex", "entityId", "5"),
		json.set ("", "name", "Survival", "ability", "wis", "entityId", "15"),
		json.set ("", "name", "Strength Ability", "ability", "str", "entityId", "dummyId"),
		json.set ("", "name", "Dexterity Ability", "ability", "dex", "entityId", "dummyId"),
		json.set ("", "name", "Constitution Ability", "ability", "con", "entityId", "dummyId"),
		json.set ("", "name", "Intelligence Ability", "ability", "int", "entityId", "dummyId"),
		json.set ("", "name", "Wisdom Ability", "ability", "wis", "entityId", "dummyId"),
		json.set ("", "name", "Charisma Ability", "ability", "cha", "entityId", "dummyId")
)]

[h: skills = "[]"]
[h, foreach (skill, preSkills), code: {
	[h, if (skillName == "_all" || skillName == json.get (skill, "name")): skills = json.append (skills, skill)] 
}]

[h: data = json.get (toon, "data")]
[h: dataRetains = json.append ("", "modifiers", "inventory", "classes", "stats", "bonusStats", "overrideStats")]
[h: skinnyData = dndb_getSkinnyObject (data, dataRetains)]
&lt;!-- Skinnify the toon --&gt;
[h: fatToon = toon]
[h: toon = json.set (toon, "data", skinnyData)]

&lt;!-- Lets call this the Rex Redrum bug: features that grant all ability checks some level of proficiency have --&gt;
&lt;!-- to be accounted for, but they wont be found tied to any particular skill --&gt;
&lt;!-- Find ALL modifiers related to ability-checks --&gt;
[h: abilitySearchArgs = json.set ("", "object", toon, 
						"subType", "ability-checks")]
[h: abilityMods = dndb_searchGrantedModifiers (abilitySearchArgs)]

&lt;!-- Now tease out the interesting bits --&gt;
&lt;!-- No need to keep searching for stuff. This arry shouldnt be very big --&gt;
[h: abilityValue = 0]
[h, foreach (abilityMod, abilityMods), code: {
	[h: value = json.get (abilityMod, "type")]
	[h, switch (value):
		case "expertise": tempAbilityValue = 3;
		case "proficiency": tempAbilityValue = 2;
		case "half-proficiency": tempAbilityValue = 1;
		default: tempAbilityValue = 0]
	[h: abilityValue = math.max (abilityValue, tempAbilityValue)]
}]

&lt;!-- The most frustrating part about any DTO is trying to sniff out the weird places for user override --&gt;
&lt;!-- values. And its an edge case anyways! So lets fetch all the relevant character values outside of --&gt;
&lt;!-- of the skill loop and just cobble up a dumb map of relevant values --&gt;
[h: characterValues = json.path.read (fatToon, "data.characterValues")]
[h: characterValuesSearchObj = json.set ("", "object", characterValues,
					"valueTypeId", SKILL_ENTITY_TYPE_ID)]
[h: skillValues = dndb_searchJsonObject (characterValuesSearchObj)]


&lt;!-- Since we cant modify existing skill objects, well build new ones instead. Stuff them into this array --&gt;
[h: afterSkillList = "[]"]

[h: toon = json.set (toon, "data", skinnyData)]
[h: skillSearchArgs = json.set ("", "object", toon,
							"entityTypeId", SKILL_ENTITY_TYPE_ID)]
[h: skillMods = dndb_searchGrantedModifiers (skillSearchArgs)]


&lt;!-- Too many uncertainties here, so just go through the skill list --&gt;
&lt;!-- Fall back to the generic search instead of more granted modifiers search --&gt;
[h, foreach (skill, skills), code: {
    [h: log.debug ("skill: " + skill)]
	[h: entityId = json.get (skill, "entityId")]
	[h: name = json.get (skill, "name")]

	&lt;!-- Start with proficiencies --&gt;
	&lt;!-- Looks for the proficiencies granted by background, class, race, etc --&gt;
	[h: searchArgs = json.set ("", "object", skillMods,
							"type", "expertise",
							"entityId", entityId)]
	[h: expertise = dndb_searchJsonObject (searchArgs)]

	[h: searchArgs = json.set (searchArgs, "type", "proficiency")]
	[h: proficiencies = dndb_searchJsonObject (searchArgs)]

	[h: searchArgs = json.set (searchArgs, "type", "half-proficiency")]
	[h: halfProfs = dndb_searchJsonObject (searchArgs)]

	&lt;!-- go from least to best --&gt;
	[h: proficientValue = 0]
	[h, if (json.length (halfProfs) &gt; 0): proficientValue = 1]
	[h, if (json.length (proficiencies) &gt; 0): proficientValue = 2]
	[h, if (json.length (expertise) &gt; 0): proficientValue = 3]

	[h: actualValue = round (math.max (abilityValue, proficientValue))]
	[h, switch (actualValue):
		case 0: proficientStr = "";
		case 1: proficientStr = "half";
		case 2: proficientStr = "proficient";
		case 3: proficientStr = "expert"
	]
	
	[h: skill = json.set (skill, "proficient", proficientStr)]

	 &lt;!-- now look for the other ridiculousness --&gt;
	[h: searchArgs = json.set ("", "object", skillValues,
					"valueId", entityId)]
	[h: characterValues = dndb_searchJsonObject (searchArgs)]
	
	[h: bonuses = "[]"]
	&lt;!-- for each choice, inspect the typeId --&gt;
	[h, foreach (characterValue, characterValues), code: {
		&lt;!-- Im at my MapTool nested code limit and I need to go deeper. There are ways around it, but lets try and play by the rules --&gt;
		&lt;!-- Just capture the machine friendly values and transform them out of this loop --&gt;
		[h: typeId = json.get (characterValue, "typeId")]
		[h, switch (typeId):
			case 23: typeLabel = "Override";
			case 24: typeLabel = "Misc. Bonus";
			case 25: typeLabel = "Magic Bonus";
			case 26: typeLabel = "Proficiency";
			case 27: typeLabel = "Stat Override";
			default: typeLabel = typeId;
		]
		[h: value = json.get (characterValue, "value")]
		[h: bonuses = json.append (bonuses, json.set ("", 
									"typeId", typeId,
									"typeLabel", typeLabel, 
									"value", value))]
	}]
	[h: skill = json.set (skill, "bonuses", bonuses)]
	&lt;!-- Weve discovered all the details, but transforming will require another more nesting --&gt;
	&lt;!-- Delegate it. --&gt;

	[h: skill = dndb_transformSkill (toon, skill)]
	[h: afterSkillList = json.append (afterSkillList, skill)]
	
}]

&lt;!-- all done --&gt;
&lt;!-- not quite! Bonus arry needs non-choice bonus also. And give the refactoring one more go --&gt;
&lt;!-- see saves as a new template --&gt;
[h: macro.return = afterSkillList]

</command>
  <label>dndb_getSkill</label>
  <group>Character</group>
  <sortby/>
  <autoExecute>true</autoExecute>
  <includeLabel>false</includeLabel>
  <applyToTokens>false</applyToTokens>
  <fontColorKey>black</fontColorKey>
  <fontSize>1.00em</fontSize>
  <minWidth/>
  <maxWidth/>
  <allowPlayerEdits>false</allowPlayerEdits>
  <toolTip>Returns an array of all skills or the requested skill, if a name is provided.

arg(0) = toon
optional: arg(1) = skillName

returns
ex.
[
	{
    "name": "Acrobatics",
    "ability": "dex",
    "valueId": "3",
    "bonuses":     [
            {
        "type": "Magic",
        "value": 0
      },
            {
        "type": "Misc",
        "value": 0
      },
            {
        "type": "Proficiency",
        "value": 0
      },
            {
        "type": "Ability",
        "value": 2
      },
            {
        "type": "Override",
        "value": -1
      }
    ],
    "proficient": "",
    "totalBonus": -1
  }
]</toolTip>
  <displayHotKey>true</displayHotKey>
  <commonMacro>false</commonMacro>
  <compareGroup>true</compareGroup>
  <compareSortPrefix>true</compareSortPrefix>
  <compareCommand>true</compareCommand>
  <compareIncludeLabel>true</compareIncludeLabel>
  <compareAutoExecute>true</compareAutoExecute>
  <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
</net.rptools.maptool.model.MacroButtonProperties>
