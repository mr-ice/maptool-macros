<net.rptools.maptool.model.MacroButtonProperties>
  <macroUUID>4b031f13-4568-4957-855c-60981f7c6fb3</macroUUID>
  <saveLocation>Token</saveLocation>
  <index>55</index>
  <colorKey>red</colorKey>
  <hotKey>None</hotKey>
  <command>&lt;!-- Constants --&gt;
[h: ATTACK_JSON = "attackJSON"]
[h: NAME = "name"]
[h: ATK_BONUS = "atkBonus"]
[h: DMG_BONUS = "dmgBonus"]
[h: DMG_DIE = "dmgDie"]
[h: DMG_DICE = "dmgDice"]
[h: CRIT_BONUS_DICE = "critBonusDice"]
[h: DMG_TYPE = "dmgType"]
[h: DMG_BONUS_EXPR = "dmgBonusExpr"]
[h: NEW_ATTACK = "New Attack"]
[h: LAST_ATTACK_SELECTION = "lastAttackSelection"]
[h: SHOW_DETAILS = "showDetails"]

&lt;!-- Check for a passed in object. Meta-macros will pass this in --&gt;
[h, if (json.length (macro.args) &gt; 0): inputObj = arg (0); inputObj = ""]

&lt;!-- Read attack JSON and prompt for selection --&gt;
[h, if (!isPropertyEmpty (ATTACK_JSON)), code: {
	&lt;!-- Property is populated. Fetch JSON data --&gt;
    [h: attackJson = getProperty(ATTACK_JSON)]
}; {
	&lt;!-- Property is empty, use blank object --&gt;
	[h: attackJson = ""]
}]

[h: arrLen = json.length(attackJson)]
[h, if (arrLen &lt; 1), code: {
	&lt;!-- no attacks found, so create one in the config macro --&gt;
	[h, macro("Attack Config@global"): ""]
	[h: attackJson = getProperty(ATTACK_JSON)]
}; {
    &lt;!-- no-op --&gt;
}]

&lt;!-- Trying to find the right balance between using Input w/ some contextual information and avoiding
	 the PITA of writing a Form macro --&gt;
[h, if (isPropertyEmpty (SHOW_DETAILS)): showDetails = 0; showDetails = getProperty (SHOW_DETAILS)]

&lt;!-- Build an attack list to pick from. Also, build a detailed label set for the input, if desired --&gt;
[h: attackList = ""]
[h: inputLabelList = ""]
[h, foreach (attack, attackJson), code: {
	[h: attackList = json.append(attackList, json.get(attack, NAME))]
	[h: inputLabelList = inputLabelList + "nothing | nothing | " + json.get(attack, NAME) +
		": atk=" + json.get(attack,ATK_BONUS) + ", dmg=" + json.get(attack, DMG_DICE) +
		"d" + json.get(attack, DMG_DIE) + " + " + json.get(attack, DMG_BONUS) +
		" + " + json.get(attack, DMG_BONUS_EXPR) + "|LABEL | text=false ##"]
}]
&lt;!-- A little separator --&gt;
[h: inputLabelList = inputLabelList + "nothing | ------------------------------------ | --------------------------------------------------- | label | ##"]
&lt;!-- Locate the index of the last selection to make it the default selection --&gt;
[h: lastSelection = getProperty(LAST_ATTACK_SELECTION)]
[h: selectedIndex = json.indexOf(attackList, lastSelection)]
[h: selectedIndex = if (selectedIndex &lt; 0, 0, selectedIndex)]

&lt;!-- User Input --&gt;
[h, if (encode (inputObj) == ""), code: { 
	[h: abort( input( "selectedAttack | " + json.toList(attackList) + " | Select Attack | list | value=string select=" + selectedIndex,
    		"advantageDisadvantage|None,Advantage,Disadvantage|Advantage/Disadvantage|list|value=string",
    		"saveAsMacro | 0 | Save as Macro | Check"))]
}]
[h, if (encode (inputObj) != ""), code: {
	[h: selectedAttack = json.get (inputObj, "selectedAttack")]
	[h: advantageDisadvantage = json.get (inputObj, "advantageDisadvantage")]
	[h: saveAsMacro = 0]
}]

&lt;!-- Save the selection for next execution as the default selection --&gt;
[h: setProperty(LAST_ATTACK_SELECTION, selectedAttack)]
[h: setProperty(SHOW_DETAILS, showDetails)]

&lt;!-- Attack selected! Fetch the JSON for the selected attack. --&gt;
[h, foreach (attack, attackJson), code: {
	[h: attackName = json.get(attack, NAME)]
	[h, if (attackName == selectedAttack), code: {
		[cfgAttack = attack]
	};{ 0 }]
}]

&lt;!-- transfer json properties to input vars --&gt;
[h: attackBonus = json.get(cfgAttack, ATK_BONUS)]
[h: dmgBonus = json.get(cfgAttack, DMG_BONUS)]
[h: dmgDie = json.get(cfgAttack, DMG_DIE)]
&lt;!-- Some weapons dont do damage and probably shouldnt be here. But dont let that stop the show --&gt;
[h, if (dmgDie == ""): dmgDie = 0]
[h: dmgNumDice = json.get(cfgAttack, DMG_DICE)]
[h, if (dmgNumDice == ""): dmgNumDice = 0]
[h: attackName = json.get(cfgAttack, NAME)]
[h: critBonus = json.get(cfgAttack, CRIT_BONUS_DICE)]
[h: dmgType = json.get(cfgAttack, DMG_TYPE)]
[h: dmgBonusExpr = json.get(cfgAttack, DMG_BONUS_EXPR)]

&lt;!-- Roll attack dice (always roll two, determine if advantage or disadvantage applies after --&gt;
&lt;!-- Unlike dmg rolls that use a full text expression, attack is done in discrete steps to determine criticals --&gt;
[h: attack = 1d20]
[h: attack2 = 1d20]

&lt;!-- Calculate the correct attack roll --&gt;
[h: realAttack = attack]
[h,if (advantageDisadvantage == "Advantage"): realAttack = max(attack, attack2)]
[h,if (advantageDisadvantage == "Disadvantage"): realAttack = min(attack, attack2)]

&lt;!-- Apply critical --&gt;
[h,if (realAttack == 20): dmgNumDice = (dmgNumDice * 2) + critBonus]

&lt;!-- Roll damage --&gt;
[h: dmgExpression = dmgNumDice + "d" + dmgDie + " + " + dmgBonus]
[h: noDmgExpression = json.equals(dmgBonusExpr, "") + json.equals(dmgBonusExpr, 0)]
[h: dmgExpression = if (noDmgExpression &gt; 0, dmgExpression, dmgExpression + " + " + dmgBonusExpr)]
[h: dmg = eval(dmgExpression)]

&lt;!-- Build the message --&gt;
[h: atkString = "&lt;b&gt;"]
[h: atk2String = "&lt;b&gt;"]
[h,if(attack == 20): atkString = atkString + "&lt;font color='red'&gt;&lt;i&gt;CRITICAL&lt;/i&gt;&lt;/font&gt; "]
[h,if(attack2 == 20): atk2String = atk2String + "&lt;font color='red'&gt;&lt;i&gt;CRITICAL&lt;/i&gt;&lt;/font&gt; "]
[h: attack = attack + attackBonus]
[h: attack2 = attack2 + attackBonus]
[h: realAttack = realAttack + attackBonus]
[h,if(advantageDisadvantage != "None"): realAtkString = "&lt;b&gt;" + realAttack + "&lt;/b&gt;"]
[h: atkString = atkString + attack + "&lt;/b&gt;"]
[h: atk2String = atk2String + attack2 + "&lt;/b&gt;"]

[h: nameStr = attackName + "&lt;br&gt;(" + dmgType + ")&lt;br&gt;&lt;br&gt;"]
[h: atkStr = "Attack (1d20 + " + attackBonus + "): " + atkString + "&lt;br&gt;"]
[h,if(advantageDisadvantage != "None"): atkStr = atkStr + advantageDisadvantage + ": " + atk2String + "&lt;br&gt;&lt;br&gt;Actual Attack: " + realAtkString + "&lt;br&gt;"]
[h: dmgStr = "Damage (" + dmgExpression + "): " + dmg]

[r: nameStr]
[r: atkStr]
[r: dmgStr]

&lt;!-- Build the macro --&gt;
[h, if (saveAsMacro &gt; 0), code: {
	[h: cmdArg = json.set ("", "selectedAttack", selectedAttack, 
							"advantageDisadvantage", advantageDisadvantage)]
	[h: advLabel = ""]
	[h, if (advantageDisadvantage == "Advantage"): advLabel = " (+)"]
	[h, if (advantageDisadvantage == "Disadvantage"): advLabel = " (-)"]
	[h: macroName = selectedAttack + advLabel + " Attack"]
	[h: currentMacros = getMacros()]
	[h: cmd = "[macro ('Make Attack@Lib:DnDBeyond'): '" + cmdArg + "']"]
	&lt;!-- dont create duplicates --&gt;
	[h, foreach (currentMacro, currentMacros), if (currentMacro == macroName): saveAsMacro = 0]
	[h: macroConfig = json.set ("", "applyToSelected", 1,
								"autoExecute", 1,
								"color", "red",
								"fontSize", "1.05em",
								"fontColor", "black",
								"group", "D&amp;D Beyond - Attacks",
								"playerEditable", 1)]
	[h, if (saveAsMacro &gt; 0): createMacro (macroName, cmd, macroConfig)]
}]</command>
  <label>Make Attack</label>
  <group>Token</group>
  <sortby>1</sortby>
  <autoExecute>true</autoExecute>
  <includeLabel>false</includeLabel>
  <applyToTokens>true</applyToTokens>
  <fontColorKey>black</fontColorKey>
  <fontSize>1.05em</fontSize>
  <minWidth/>
  <maxWidth/>
  <allowPlayerEdits>false</allowPlayerEdits>
  <toolTip>Do the deed</toolTip>
  <displayHotKey>false</displayHotKey>
  <commonMacro>false</commonMacro>
  <compareGroup>true</compareGroup>
  <compareSortPrefix>true</compareSortPrefix>
  <compareCommand>true</compareCommand>
  <compareIncludeLabel>true</compareIncludeLabel>
  <compareAutoExecute>true</compareAutoExecute>
  <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
</net.rptools.maptool.model.MacroButtonProperties>
